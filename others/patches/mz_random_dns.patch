diff -rupN mz-0.40//src/dns.c mz-0.40_patched//src/dns.c
--- mz-0.40//src/dns.c	2009-08-19 22:47:01.000000000 +0300
+++ mz-0.40_patched//src/dns.c	2013-09-09 21:51:47.609276268 +0300
@@ -90,13 +90,13 @@
 		"\n"
 
 
-int dns_get_query (char* argval);
+int dns_get_query (char* argval, int type);
 int dns_get_answer (char* argval);
 
 
 
 // Note: I do NOT use libnet here (had problems with bugs there...)
-int create_dns_packet ()
+int create_dns_packet (int dns_type)
 {
    
    char  *token, *tokenptr, argval[MAX_PAYLOAD_SIZE];
@@ -184,15 +184,15 @@ int create_dns_packet ()
    /////////////////////////////////////////////////////////////////////////////////
    // Evaluate CLI parameters:
 
-   
+      
    //  Handle the query //
 
-   if ( (getarg(tx.arg_string,"query", argval)==1) ||
-	(getarg(tx.arg_string,"q", argval)==1) )
-     {
+   if ( dns_type == 1)
+   {
+      if ( (getarg(tx.arg_string,"query", argval)==1) || (getarg(tx.arg_string,"q", argval)==1) )
+      {
+	(void) dns_get_query (argval, dns_type); // returns the length in byte	dns_num_q0=1;
 
-	(void) dns_get_query (argval); // returns the length in byte	dns_num_q0=1;
-	
 	// copy the result from gbuf to our local buffer 'section':
 	for (j=0;j<gbuf_s;j++)
 	  {
@@ -221,7 +221,40 @@ int create_dns_packet ()
 	dns_flags_rcode        = 0; // no errors
 	dns_num_q0             = 1; // number of questions
      }
+   }
+   else
+   {
+	(void) dns_get_query (argval, dns_type); // returns the length in byte dns_num_q0=1;
+
+        // copy the result from gbuf to our local buffer 'section':
+        for (j=0;j<gbuf_s;j++)
+          {
+             section[j]=gbuf[j];
+          }
+
+        i = gbuf_s;
+
+        // Set defaults if not already set by callee.
+        // !! But ONLY set these if there is no additional answer section
+        // !! because then the answer section should set the defaults !!!
+        if ( (getarg(tx.arg_string,"answer", NULL)==0) && // no answer
+             (getarg(tx.arg_string,"a", NULL)==0) )
+          {
+             if (!tx.dp)     tx.dp = 53;
+             if (!tx.sp)     tx.sp = 42000;
+          }
+
+
+        // These are the defaults for a query:
+        dns_flags_aa           = 1; // authoritative answer
+        dns_flags_tc           = 0; // not truncated
+        dns_flags_rd           = 1; // recursion desired
+        dns_flags_ra           = 0; // recursion available
+        dns_flags_z            = 0; // FYI: if 010 = 2 = authenticated
+        dns_flags_rcode        = 0; // no errors
+        dns_num_q0             = 1; // number of questions
 
+   }
 
    
    // Handle the answer:
@@ -525,6 +558,24 @@ int create_dns_packet ()
 }
 
 
+// galkan
+char  *gen_random(char *s, const int len) 
+{
+    int i;
+    static const char alphanum[] =
+        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+        "abcdefghijklmnopqrstuvwxyz";
+
+    for (i = 0; i < len; ++i) 
+    {
+        s[i] = alphanum[rand() % (sizeof(alphanum) - 1)];
+    }
+   
+    s[len] = 0;
+    return s;
+}
+// galkan
+
 
 ////////////////////////////////////////////////////////////////////////////////////////////
 // Accepts a string like "www.perihel.at:A" or "www.perihel.at"
@@ -534,8 +585,9 @@ int create_dns_packet ()
 // Return value: 
 //   number of queries (currently only 1 query accepted, 
 //   hence return value is 1 on success or 0 upon failure
-//   
-int dns_get_query(char* argval)
+//  
+ 
+int dns_get_query(char* argval, int type)
 {
    char *token, *field, *saveptr1=NULL, *saveptr2=NULL;
    int i,j, cnt;
@@ -544,11 +596,45 @@ int dns_get_query(char* argval)
    
    i=0;
    
+ 
+   if ( type == 1 )
+   {	
+   	char *new_argval = (char *)(malloc(512));
+   	new_argval = gen_random(new_argval,5);
+   	strcat(new_argval, ".");	
+   	strcat(new_argval, argval);
+   	strcpy(argval, new_argval);
+	free(new_argval);	
+   }
+   else
+   {
+	char *new_argval = (char *)(malloc(512));
+	char *tmp = (char *)(malloc(512));
+
+        tmp = gen_random(tmp,3);
+	strcat(tmp, ".");
+	strcpy(new_argval, tmp);
+
+	tmp = gen_random(tmp, 8);
+	strcat(tmp, ".");
+	strcat(new_argval, tmp);
+
+	tmp = gen_random(tmp, 3);
+	strcat(new_argval, tmp);
+
+	strcpy(argval, new_argval);	
+
+
+        free(new_argval);
+	free(tmp);
+   }
+
    // now get first field: <name>
    field = strtok_r(argval, ":", &saveptr1);
    
    // decompose <name> into labels:
    token = strtok_r(field, ".", &saveptr2);
+ 
 
    do   // loop through all labels 
      {
diff -rupN mz-0.40//src/init.c mz-0.40_patched//src/init.c
--- mz-0.40//src/init.c	2010-07-07 17:31:10.000000000 +0300
+++ mz-0.40_patched//src/init.c	2013-09-09 21:51:47.613276291 +0300
@@ -212,7 +212,7 @@ int getopts (int argc, char *argv[])
 	opterr = 1; // let getopt print error message if necessary
 	
 	
-	while ((c = getopt (argc, argv, "hqvVSxra:A:b:B:c:d:f:F:p:P:t:T:M:Q:X:")) != -1)
+	while ((c = getopt (argc, argv, "hqvVSxra:A:b:B:c:d:f:F:p:P:t:T:M:Q:X:g:")) != -1)
 		switch (c) {
 		 case 'h':
 			usage();
@@ -290,6 +290,10 @@ int getopts (int argc, char *argv[])
 		 case 't':
 			packet_type = optarg; // analyzed below
 			break;
+		 case 'g':
+			strcpy(optarg, "random_dns");
+                        packet_type = optarg; // analyzed below
+                        break;
 		 case 'X':
 			mops_type = optarg; // MOPS TRANSITION STRATEGY -- analyzed below
 			break;
@@ -575,7 +579,7 @@ int getopts (int argc, char *argv[])
 		}
 	}
 	
-	
+
    if (packet_type == NULL) { // raw hex string given
 	   mode = BYTE_STREAM;
    }
@@ -600,6 +604,9 @@ int getopts (int argc, char *argv[])
 	else if (strcmp(packet_type,"dns")==0) {
 		mode = DNS;
 	}
+	else if (strcmp(packet_type,"random_dns")==0) {
+                mode = RANDOM_DNS;
+        }
 	else if (strcmp(packet_type,"cdp")==0) {
 		mode = CDP;
 	}
diff -rupN mz-0.40//src/mz.c mz-0.40_patched//src/mz.c
--- mz-0.40//src/mz.c	2010-06-02 00:06:21.000000000 +0300
+++ mz-0.40_patched//src/mz.c	2013-09-09 21:51:47.613276291 +0300
@@ -127,7 +127,7 @@ void usage()
 		   "|                        encapsulations in lower layers. Most packet types allow/require\n"
 		   "|                        additional packet-specific arguments in an arg_string.\n"
 		   "|                        Currently supported types: arp, bpdu, cdp, ip, icmp, udp, tcp,\n"
-		   "|                        dns, rtp, syslog, lldp.\n"
+		   "|                        dns, rtp, syslog, lldp, random_dns.\n"
 		   "|                        For context-help use 'help' as arg_string!\n"
 		   "|  -T <packet_type>      Specify packet type for server mode. Currently only rtp is supported.\n"
 		   "|                        Enter -T help or -T rtp help for further information.\n"
@@ -148,13 +148,14 @@ void usage()
 int main(int argc, char *argv[])
 {
 
-   
    // These handles are only used when creating L3 and above packets.
    libnet_t             *l;               // the context 
    libnet_ptag_t         t2=0, t3=0, t4=0;      // handles to layers 
    
    double cpu_time_used;
 
+   int sayac, dns_type;
+
    // Check if we have root priviliges
    if ( (getuid()!=0) && (geteuid()!=0) )
      {
@@ -250,6 +251,7 @@ int main(int argc, char *argv[])
 	  send_frame (l, t3, t4); // NOTE: send_frame also destroys context finaly
 	break;
 	
+
       case TCP:
 	tx.ip_proto = 6;    
 	l = get_link_context();
@@ -261,20 +263,46 @@ int main(int argc, char *argv[])
 	else
 	  send_frame (l, t3, t4); // NOTE: send_frame also destroys context finaly
 	break;
-	
+
+
       case DNS:
 	tx.ip_proto = 17;
-	l = get_link_context();
-	(void) create_dns_packet();
-	t4 = create_udp_packet(l);     // t4 can be used for later header changes
-	t3 = create_ip_packet(l);      // t3 can be used for later header changes
-	if (!quiet) complexity();
-	if (tx.packet_mode==0)         // Ethernet manipulation features does NOT use ARP to determine eth_dst  
-	  t2 = create_eth_frame(l, t3, t4);    // t2 can be used for later header changes
-	else
-	  send_frame (l, t3, t4); // NOTE: send_frame also destroys context finaly
+	dns_type = 1;
+	for (sayac=0; sayac<tx.count; sayac++)
+	{
+		l = get_link_context();
+		(void) create_dns_packet(dns_type);
+		t4 = create_udp_packet(l);     // t4 can be used for later header changes
+		t3 = create_ip_packet(l);      // t3 can be used for later header changes
+		if (!quiet) complexity();
+
+		if (tx.packet_mode==0)         // Ethernet manipulation features does NOT use ARP to determine eth_dst  
+	  		t2 = create_eth_frame(l, t3, t4);    // t2 can be used for later header changes
+		else
+  			send_dns_frame(l, t3, t4); // NOTE: send_frame also destroys context finaly
+	}
 	break;
-	
+
+
+      case RANDOM_DNS:
+        tx.ip_proto = 17;
+	dns_type = 2;
+        for (sayac=0; sayac<tx.count; sayac++)
+        {
+                l = get_link_context();
+                (void) create_dns_packet(dns_type);
+                t4 = create_udp_packet(l);     // t4 can be used for later header changes
+                t3 = create_ip_packet(l);      // t3 can be used for later header changes
+                if (!quiet) complexity();
+
+                if (tx.packet_mode==0)         // Ethernet manipulation features does NOT use ARP to determine eth_dst
+                        t2 = create_eth_frame(l, t3, t4);    // t2 can be used for later header changes
+                else
+                        send_dns_frame(l, t3, t4); // NOTE: send_frame also destroys context finaly
+        }
+        break;
+
+
       case RTP:
 	tx.ip_proto = 17;
 	l = get_link_context();
diff -rupN mz-0.40//src/mz.h mz-0.40_patched//src/mz.h
--- mz-0.40//src/mz.h	2010-06-22 01:10:59.000000000 +0300
+++ mz-0.40_patched//src/mz.h	2013-09-09 21:51:47.613276291 +0300
@@ -247,7 +247,8 @@ enum operating_modes
      RTP,
      RX_RTP,
      SYSLOG,
-     LLDP
+     LLDP,
+     RANDOM_DNS	
 } mode;
 
 
@@ -521,6 +522,7 @@ int send_cdp ();
 libnet_t*      get_link_context();
 libnet_ptag_t  create_ip_packet (libnet_t *l);
 int            send_frame (libnet_t *l, libnet_ptag_t  t3, libnet_ptag_t  t4);
+int            send_dns_frame (libnet_t *l, libnet_ptag_t  t3, libnet_ptag_t  t4);
 
 
 
@@ -539,7 +541,7 @@ libnet_ptag_t  create_tcp_packet (libnet
 //   Prototypes: Layer 7
 //
 // ************************************
-int  create_dns_packet ();
+int  create_dns_packet (int control);
 int  create_rtp_packet();
 int create_syslog_packet();
 
diff -rupN mz-0.40//src/send.c mz-0.40_patched//src/send.c
--- mz-0.40//src/send.c	2009-08-25 22:02:02.000000000 +0300
+++ mz-0.40_patched//src/send.c	2013-09-09 21:51:47.613276291 +0300
@@ -131,12 +131,13 @@ int complexity()
      {
 	cli_print(gcli, "Mausezahn will send %.Lf frames...\r", total_d);
      }
-   else
-     {
-	fprintf(stderr, "Mausezahn will send %.Lf frames... ", total_d);
-	fflush(stderr);
-	if (verbose) fprintf(stderr,"\n");
-     }
+   //else
+     //{
+	//fprintf(stderr, "Mausezahn will send %.Lf frames... ", total_d);
+	//fprintf(stderr, "... ");
+	//fflush(stderr);
+	//if (verbose) fprintf(stderr,"\n");
+    // }
    
    
    
@@ -262,3 +263,102 @@ int send_frame (libnet_t *l, libnet_ptag
    return 0;
 }
 
+
+
+///////////////////////////////////////////////////////////////////////
+//
+// Send complete frame (layers 2, 3, 4) multiple times if required
+// 
+// 
+int send_dns_frame (libnet_t *l, libnet_ptag_t  t3, libnet_ptag_t  t4)
+{
+   int count;
+
+   int // local vars are faster ;-)
+     tcp_seq_delta,
+     dp_isrange,
+     sp_isrange,
+     ip_dst_isrange,
+     ip_src_isrange,
+     rtp_mode=0;
+
+   
+   count = tx.count;
+   tcp_seq_delta = tx.tcp_seq_delta;
+   dp_isrange = tx.dp_isrange;
+   sp_isrange = tx.sp_isrange;
+   ip_dst_isrange = tx.ip_dst_isrange;
+   ip_src_isrange = tx.ip_src_isrange | tx.ip_src_rand;
+   if (mode == RTP) rtp_mode = 1;
+   
+   //if (count==0) goto AGAIN;
+   //for (i=0; i<count; i++)
+   //{
+
+	AGAIN:
+
+	if (verbose) (void) print_frame_details();
+	libnet_write(l);
+	if (mz_rand) tx.delay=(unsigned int) tx.delay*rand()/RAND_MAX;
+	if (tx.delay) SLEEP (tx.delay);
+	
+	//   No layer-2 modifications done here 
+	//   (see create_eth_frame which does L2 modifications additionally)
+
+	
+	if (tcp_seq_delta)
+	  {
+	     if (update_TCP_SQNR(l, t4)==0) // end of range not yet reached
+	       {
+		  goto AGAIN;
+	       }
+	  }
+	
+	if (dp_isrange)
+	  {
+	     if (update_DPORT(l, t4)==0) // end of range not yet reached
+	       {
+		  goto AGAIN;
+	       }
+	  }
+	
+	if (sp_isrange)
+	  {
+	     if (update_SPORT(l, t4)==0) // end of range not yet reached
+	       {
+		  goto AGAIN;
+	       }
+	  }
+	
+
+	if (ip_dst_isrange)
+	  {
+	     if (update_IP_DA(l, t3)==0) // end of range not yet reached
+	       {
+		  goto AGAIN;
+	       }
+	  }
+	
+	if (ip_src_isrange) // also catches random SA (see above)
+	  {
+	     if (update_IP_SA(l, t3)==0) // end of range not yet reached
+	       {
+		  goto AGAIN;
+	       }
+	  }
+
+	if (rtp_mode) // update SQNR and Timestamps in RTP header and payload
+	  {
+	     update_RTP(l, t4);
+	  }
+	
+	
+	if (!count) goto AGAIN;
+     //}
+   
+   libnet_destroy(l);
+   
+   return 0;
+}
+
+
diff -rupN mz-0.40//src/tx_switch.c mz-0.40_patched//src/tx_switch.c
--- mz-0.40//src/tx_switch.c	2010-03-07 14:44:55.000000000 +0200
+++ mz-0.40_patched//src/tx_switch.c	2013-09-09 21:51:47.613276291 +0300
@@ -100,7 +100,7 @@ int tx_switch(struct cli_def *cli)
       case DNS:
 	tx.ip_proto = 17;
 	l = get_link_context();
-	if (create_dns_packet()==-1) return 0;
+	if (create_dns_packet(1)==-1) return 0;
 	t4 = create_udp_packet(l);     // t4 can be used for later header changes
 	t3 = create_ip_packet(l);      // t3 can be used for later header changes
 	if (!quiet) complexity();
